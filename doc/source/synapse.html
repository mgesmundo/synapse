<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='node_modules-synapsejs'>/**
</span> * Distributed RPC server and client.
 *
 * ## Installation
 * 
 * Install `synapsejs` as usual via [npm](http://npmjs.org).
 * 
 * ```sh
 * $ npm install synapsejs --save
 * ```
 * 
 * ## Quick Start
 * 
 * In this simple scenario we have two nodes that expose two methods. The third node is a client-only consumer.
 * 
 * ### First node
 * 
 * Save the following file as `node1.js`.
 * 
 * ```js
 * var Synapse = require('synapsejs')();
 * var node1 = new Synapse({
 *   name: 'node1'
 * });
 * node1.expose({
 *   sum: function (a, b, cb) {
 *     cb(null, a + b);
 *   },
 *   sub: function (a, b, cb) {
 *     cb(null, a - b);
 *   }
 * });
 * node1.start(function () {
 *   console.log('node1 is ready');
 * });
 * ```
 * 
 * ### Second node
 * 
 * Save the following file as `node2.js`.
 * 
 * ```js
 * var node2 = new Synapse({
 *   name: 'node2'
 * });
 * node2.expose({
 *   mul: function (a, b, cb) {
 *     cb(null, a * b);
 *   },
 *   div: function (a, b, cb) {
 *     cb(null, a / b);
 *   }
 * });
 * node2.start(function () {
 *   console.log('node2 is ready');
 * });
 * ```
 * 
 * ### Third node
 * 
 * Save the following file as `node3.js`.
 * 
 * ```js
 * var node3 = new Synapse({
 *   name: 'node3'
 * });
 * var announces = 0;
 * node3.on('announce', function (config) {
 *   console.log('announce from ' + config.name);
 *   announces++;
 *   if (announces === 2) {
 *   // all nodes are up
 *     node3.execute('sum', 1, 2, function (err, result) {
 *       console.log('sum = ' + result);
 *     });
 *     node3.execute('sub', 1, 2, function (err, result) {
 *       console.log('sub = ' + result);
 *     });
 *     node3.execute('mul', 1, 2, function (err, result) {
 *       console.log('nul = ' + result);
 *     });
 *     node3.execute('div', 1, 2, function (err, result) {
 *       console.log('div = ' + result);
 *     });
 *   }
 * });
 * node3.start(function () {
 *   console.log('node3 is ready');
 * });
 * node3.on('destroy', function (service) {
 *   console.log('node ' + service.name + ' is no longer available');
 * });
 * ```
 * 
 * In three terminal windows (in the same or different pc) start this three small apps:
 * 
 * ```bash
 * t1 $ node node1.js
 * node1 is ready
 * ```
 * 
 * ```bash
 * t2 $ node node2.js
 * node2 is ready
 * ```
 * 
 * ```bash
 * t3 $ node node3.js
 * node3 is ready
 * announce from node1
 * announce from node2
 * sum = 3
 * sub = -1
 * nul = 2
 * div = 0.5
 * ```
 * The last terminal window shows the results.
 * 
 * @class node_modules.synapsejs
 * @singleton
 *
 * @author Marcello Gesmundo
 *
 * # License
 *
 * Copyright (c) 2014 Yoovant by Marcello Gesmundo. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *    * Neither the name of Yoovant nor the names of its
 *      contributors may be used to endorse or promote products derived
 *      from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

var _ = require('underscore');
var useit = require('useit');
var Manager = require('port-manager');
var RpcEventEmitter = require('multicast-events').EventEmitter;
var LocalEventEmitter = require('events').EventEmitter;
var debug = require('debug')('synapse');
var util = require('util');
var ip = require('ip');
var tcpUtil = require('./tcp-util');
var axonRpc = require('axon-rpc');
var axon = require('axon-secure');
var Service = require('./service');
var Args = require('vargs').Constructor;
var norm = require('normalize-arguments');

function _expose(cfg, localEmitter, rpc) {
  var self = this;
  return function expose(name, fn) {
    if (self.ghost) {
      var error = new Error(util.format('%s unable expose methods in ghost mode', self.name));
      localEmitter.emit(cfg.errorEvent, error);
    } else {
      var keys;
      if (_.isObject(name) &amp;&amp; !fn) {
        keys = _.keys(name);
        debug('%s expose &quot;%s&quot; methods', self.name, keys.join(', '));
        _.each(keys, function (key) {
          rpc.expose(key, name[key]);
        });
      } else {
        debug('%s expose &quot;%s&quot; method', self.name, name);
        rpc.expose(name, fn);
      }
      localEmitter.emit(cfg.exposeEvent, name, fn);
    }
    return self;
  };
}

function _announce(cfg, localEmitter, rpcEmitter) {
  var self = this;
  return function announce() {
    if (self.ghost) {
      var error = new Error(util.format('%s unable announce in ghost mode', self.name));
      localEmitter.emit(cfg.errorEvent, error);
    } else {
      debug('%s emit &quot;%s&quot;: %o', self.name, cfg.announceEvent, self.config);
      rpcEmitter.emit(cfg.announceEvent, self.config);
    }
    return self;
  };
}

function _discovery(cfg, rpcEmitter) {
  var self = this;
  return function discovery() {
    debug('%s emit &quot;%s&quot;', self.name, cfg.discoveryEvent);
    rpcEmitter.emit(cfg.discoveryEvent);
    return self;
  };
}

function _execute(cfg, localEmitter) {
  var self = this;
  return function execute() {
    var args = new Args(arguments);
    if (args.length &lt; 2) {
      localEmitter.emit(cfg.errorEvent, new Error('insufficient arguments'));
      return;
    }
    if (!args.callbackGiven()) {
      localEmitter.emit(cfg.errorEvent, new Error('callback required'));
      return;
    }
    // extract method, service, address and port
    var re = /(^[\w\s&amp;\(\)\[\]\{\}\-]+){1}(@?(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):?(\d*))?(\.(\d*\w*))?/;
    var fullMethod = args.first.match(re);
    if (_.isEmpty(fullMethod[0])) {
      localEmitter.emit(cfg.errorEvent, new Error('wrong qualified method'));
      return;
    }
    var method, name, address, port;
    if (fullMethod[6]) {
      method = fullMethod[6];
      name = fullMethod[1];
    }
    if (fullMethod[2]) {
      if (!method) {
        localEmitter.emit(cfg.errorEvent, new Error('wrong qualified method'));
        return;
      }
      address = fullMethod[3];
      port = fullMethod[4];
    }
    if (name &amp;&amp; !method) {
      method = name;
      name = undefined;
    } else if (!name &amp;&amp; !method) {
      method = fullMethod[1];
    }
    var services;
    // find the service
    if (method &amp;&amp; !name) {
      services = Service.findByMethod(method);
    } else {
      var filter = {
        name: name
      };
      if (address) {
        filter.address = address;
      }
      if (port) {
        filter.port = parseInt(port, 10);
      }
      services = Service.find(filter);
    }
    var params = args.array;
    if (_.isEmpty(services)) {
      args.callback(new Error('method not found'));
    } else if (services.length &gt; 1) {
      args.callback(new Error('not unique method found'));
    } else {
      // remove full qualified service name
      params.shift();
      // add method name
      params.unshift(method);
      // execute the remote method
      var service = services[0];
      debug('%s execute &quot;%s&quot; exposed by &quot;%s@%s:%d&quot;', self.name, method, service.name, self.address, self.port);
      service.client.call.apply(service.client, params);
    }
    return self;
  };
}

function _onAnnounce(cfg, localEmitter) {
  var self = this;

  return function onAnnounce(config) {
    // remove parent property for debug purpose only
    delete config.parent;
    debug('%s receive &quot;%s&quot; from %o', self.name, cfg.announceEvent, config);
    if (self.checkService(config, true)) {
      debug('%s service %o is in blacklist', self.name, config);
      localEmitter.emit(cfg.blacklistEvent, config);
      return;
    }
    // add new service or update existing
    var service = Service.createService({
      parent: self.name,
      name: config.name,
      address: config.address,
      port: config.port,
      meta: config.meta,
      emitter: localEmitter
    });
    if (service instanceof Error) {
      debug('%s %o', self.name, service.message);
      localEmitter.emit(cfg.errorEvent, service);
    } else if (service.isNew) {
      debug('%s on announce save new service %o', self.name, {
        name: service.name,
        address: service.address,
        port: service.port,
        meta: service.meta
      });
      service.save();
    } else {
      debug('%s on announce update service %o', self.name, {
        name: service.name,
        address: service.address,
        port: service.port,
        meta: service.meta
      });
      service.update();
    }
  };
}

function _onDiscovery(cfg, localEmitter, rpcEmitter) {
  var self = this;
  return function onDiscovery(rinfo) {
    if (self.ghost) {
      var error = new Error(util.format('%s unable handle discovery in ghost mode', self.name));
      localEmitter.emit(cfg.errorEvent, error);
    } else {
      debug('%s receive &quot;%s&quot; from %s:%d', self.name, cfg.discoveryEvent, rinfo.address, rinfo.port);
      // a discovery request is handled as new announce event in a random time slot
      // to avoid simultaneous announce events from other services
      var tout = Math.floor(Math.random() * cfg.discoveryDelay);
      debug('%s emit &quot;%s&quot; in %d ms', self.name, cfg.announceEvent, tout);
      setTimeout(function () {
        rpcEmitter.emit(cfg.announceEvent, self.config);
      }, tout);
    }
  };
}

module.exports = function (config) {
  config = config || {};
  var cfg = useit.load('./defaults').as('config').init(config);

  // create TCP port manager
  var manager = new Manager(cfg.heartbeat);
  manager.include(cfg.minSrvPort, cfg.maxSrvPort);

  var rpcCounter = 0;

<span id='node_modules-synapsejs-Rpc-method-constructor'><span id='node_modules-synapsejs-Rpc-cfg-meta'><span id='node_modules-synapsejs-Rpc-cfg-ghost'><span id='node_modules-synapsejs-Rpc-cfg-port'><span id='node_modules-synapsejs-Rpc-cfg-address'><span id='node_modules-synapsejs-Rpc-cfg-name'><span id='node_modules-synapsejs-Rpc'>  /**
</span></span></span></span></span></span></span>   * @class node_modules.synapsejs.Rpc
   * @cfg {String} [name = 'synapse #n'] The name of the instance.
   * __NOTE__: the default name used as base for the sequence if that set into the module config.
   * @cfg {String} [address] The address bound to the instance
   * @cfg {Number} [port] The port bound to the instance.
   * @cfg {Number} [ghost = false] Set true if the node do not fire announce event and do not handle discovery events.
   * @cfg {Object} [meta] Optional information about the instance (this information is exposed in config).
   * @constructor
   */
  function Rpc(opts) {
<span id='node_modules-synapsejs-Rpc-event-start'>    /**
</span>     * @event start Fired when the synapse node is up.
     * @param {Object} config The config of the started node (service).
     * @param {String} config.name The name of the service.
     * @param {String} config.address The address of the service.
     * @param {Number|String} config.port The port of the service or 'ghost' if the service is in ghost mode.
     * @param {Object} config.meta Optional information about the service.
     */

<span id='node_modules-synapsejs-Rpc-event-stop'>    /**
</span>     * @event stop Fired when the synapse node is down.
     * @param {Object} config The config of the stopped node (service).
     * @param {String} config.name The name of the service.
     * @param {String} config.address The address of the service.
     * @param {Number|String} config.port The port of the service or 'ghost' if the service is in ghost mode.
     * @param {Object} config.meta Optional information about the service.
     */

<span id='node_modules-synapsejs-Rpc-event-announce'>    /**
</span>     * @event announce Fired when the synapse node announce itself on the network.
     * An announce event occurs after a start event.
     * @param {Object} config The config of the node (service).
     * @param {String} config.name The name of the service.
     * @param {String} config.address The address of the service.
     * @param {Number} config.port The port of the service.
     * @param {Object} config.meta Optional information about the service.
     */

<span id='node_modules-synapsejs-Rpc-event-discovery'>    /**
</span>     * @event discovery Fired when the synapse node wants collect all services on the network.
     * A discovery event occur after the first announce.
     */

<span id='node_modules-synapsejs-Rpc-event-error'>    /**
</span>     * @event error Fired when an error occur.
     * @param {Error|String} err The error.
     */

<span id='node_modules-synapsejs-Rpc-event-acl'>    /**
</span>     * @event acl Fired when a new announced service match a rule into the ACL list.
     * @param {Object} config The config of the blocked node (service).
     * @param {String} config.name The name of the service.
     * @param {String} config.address The address of the service.
     * @param {Number} config.port The port of the service.
     * @param {Object} config.meta Optional information about the service.
     */

<span id='node_modules-synapsejs-Rpc-event-save'>    /**
</span>     * @event save Fired when a new discovered service is saved.
     * @param {Object} service The saved service.
     * @param {String} service.name The name of the service.
     * @param {String} service.address The address of the service.
     * @param {Number} service.port The port of the service.
     * @param {Object} service.meta Optional information about the service.
     */

<span id='node_modules-synapsejs-Rpc-event-destroy'>    /**
</span>     * @event destroy Fired when a service is not available anymore.
     * @param {Object} service The destroyed service.
     * @param {String} service.name The name of the service.
     * @param {String} service.address The address of the service.
     * @param {Number} service.port The port of the service.
     * @param {Object} service.meta Optional information about the service.
     */

<span id='node_modules-synapsejs-Rpc-event-expose'>    /**
</span>     * @event expose Fired when a method is exposed.
     * @param {String} name The name of the exposed method.
     * @param {Function} fn The function of the exposed method.
     */

    opts = opts || {};
    var localEmitter = new LocalEventEmitter();

    var _name = opts.name || util.format('%s #%d', cfg.name, rpcCounter);
<span id='node_modules-synapsejs-Rpc-property-name'>    /**
</span>     * The name of the instance
     * @property {String} name
     */
    Object.defineProperty(this, 'name', {
      get: function get() {
        return _name;
      },
      enumerable: true
    });
    var _address =  opts.address || ip.address();
<span id='node_modules-synapsejs-Rpc-property-address'>    /**
</span>     * The address bound to the instance
     * @property {String} address
     */
    Object.defineProperty(this, 'address', {
      get: function get() {
        return _address;
      },
      enumerable: true
    });
    var _port =  opts.port;
<span id='node_modules-synapsejs-Rpc-property-port'>    /**
</span>     * The port bound to the instance
     * @property {Number} port
     */
    Object.defineProperty(this, 'port', {
      get: function get() {
        return _port;
      },
      enumerable: true
    });
    var _meta = opts.meta;
<span id='node_modules-synapsejs-Rpc-property-meta'>    /**
</span>     * Optional information about the service.
     * @property {Object} [meta]
     */
    Object.defineProperty(this, 'meta', {
      get: function get() {
        return _meta;
      },
      enumerable: true
    });
    var _running = false;
<span id='node_modules-synapsejs-Rpc-property-running'>    /**
</span>     * The status of the instance.
     * @property {Boolean} running
     */
    Object.defineProperty(this, 'running', {
      get: function get() {
        return _running;
      },
      enumerable: true
    });
    var _ghost = !!opts.ghost;
<span id='node_modules-synapsejs-Rpc-property-ghost'>    /**
</span>     * True if the node is in ghost mode (no announce event fired and no discovery events handling).
     * @property {Boolean} ghost
     */
    Object.defineProperty(this, 'ghost', {
      get: function get() {
        return _ghost;
      },
      enumerable: true
    });
    var _blacklist = [];
<span id='node_modules-synapsejs-Rpc-property-blacklist'>    /**
</span>     * @property {Array} blacklist The list of the blocked services.
     */
    Object.defineProperty(this, 'blacklist', {
      get: function get() {
        return _blacklist;
      },
      enumerable: true
    });
    var _rules = [];
<span id='node_modules-synapsejs-Rpc-property-rules'>    /**
</span>     * @propety {Array} rules The list of the rules (ACLs) used to block some services.
     */
    Object.defineProperty(this, 'rules', {
      get: function get() {
        return _rules;
      },
      enumerable: true
    });

    rpcCounter++;
    var self = this;

    if (!tcpUtil.verifyAddress(_address)) {
      throw new Error(util.format('no interface is configured with %s address', _address));
    }
    var rpcEmitter = new RpcEventEmitter({
      name: cfg.rpcEmitterName,
      id: cfg.name,
      group: cfg.advAddress,
      secure: cfg.secure,
      cipher: cfg.cipher,
      secret: cfg.secret,
      ttl: cfg.ttl,
      octet: cfg.octet,
      port: cfg.minEventsPort,
      interface: cfg.interface,
      foreignOnly: true,
      events: _.extend(cfg.events, opts.events)
    });
    var rep = axon.socket('rep', {
      secure: cfg.secure,
      cipher: cfg.cipher,
      secret: cfg.secret
    });
    var rpc = new axonRpc.Server(rep);
    var announce = _announce.call(this, cfg, localEmitter, rpcEmitter);
    var discovery = _discovery.call(this, cfg, rpcEmitter);
    var expose = _expose.call(this, cfg, localEmitter, rpc);
    var execute = _execute.call(this, cfg, localEmitter);
    var onAnnounce = _onAnnounce.call(this, cfg, localEmitter);
    var onDiscovery = _onDiscovery.call(this, cfg, localEmitter, rpcEmitter);

    function start(ghost, meta, cb) {
      debug('%s start request', self.name);

      var args = norm(arguments, [norm.boolean(_ghost), norm.object(_meta), norm.fn(undefined)]);
      ghost = !!args[0];
      meta = args[1];
      cb = args[2];

      _ghost = ghost;
      _meta = meta;

      function listen() {
        var startTimeout = setTimeout( function () {
          _running = false;
          var error = new Error(util.format('%s start timeout', self.name));
          localEmitter.emit(cfg.errorEvent, error);
          cb &amp;&amp; cb(error);
        }, cfg.timeout);

        // listen foreign only announce events
        rpcEmitter.on(cfg.announceEvent, onAnnounce);
        // listen foreign only discovery events
        rpcEmitter.on(cfg.discoveryEvent, onDiscovery);

        debug('%s bind port %d', self.name, self.port);

        rep.bind(self.port, function () {
          clearTimeout(startTimeout);
          debug('%s emit &quot;%s&quot; config %o', self.name, cfg.startEvent, self.config);
          _running = true;
          localEmitter.emit(cfg.startEvent, self.config);
          cb &amp;&amp; cb(null, self.config);
          self.announce();
          self.discovery();
        });
      }
      if (!_ghost) {
        if (opts.port) {
          debug('%s claim TCP port %d for &quot;%s&quot;', self.name, opts.port, cfg.name);
        } else {
          debug('%s claim a free TCP port for &quot;%s&quot;', self.name, cfg.name);
        }
        // get a free TCP port
        manager.claim(self.name, opts.port, function (err, service) {
          if (err) {
            err = new Error(err);
            localEmitter(cfg.errorEvent, err);
            cb &amp;&amp; cb(err);
          } else {
            _port = service.port;
            listen();
          }
        });
      } else if (_.isEmpty(rpc.methods)) {
        // listen foreign only announce events
        rpcEmitter.on(cfg.announceEvent, onAnnounce);
        _running = true;
        var ghostConfig = {
          name: self.name,
          address: self.address,
          port: 'ghost',
          meta: self.meta
        };
        debug('%s emit &quot;%s&quot; config %o', self.name, cfg.startEvent, ghostConfig);
        localEmitter.emit(cfg.startEvent, ghostConfig);
        cb &amp;&amp; cb(null, ghostConfig);
        self.discovery();
      } else {
        var error = new Error(util.format('%s unable start in ghost mode with exposed methods', self.name));
        localEmitter.emit(cfg.errorEvent, error);
        cb &amp;&amp; cb(error);
      }
      return this;
    }

    function stop(cb) {
      debug('%s stop request', self.name);
      // the running status is unknown until the shutdown is complete
      _running = null;

      var stopTimeout = setTimeout(function () {
        var error = new Error(util.format('%s stop timeout', self.name));
        localEmitter.emit(cfg.errorEvent, error);
        cb &amp;&amp; cb(error);
      }, cfg.timeout);

      function callback(cb) {
        if (relatedServicesDestroyed &amp;&amp; repClosed) {
          clearTimeout(stopTimeout);
          debug('%s emit &quot;%s&quot;', self.name, cfg.stopEvent);
          _running = false;
          localEmitter.emit(cfg.stopEvent, self.config);
          cb &amp;&amp; cb(null, self.config);
        }
      }

      // remove listeners
      setImmediate(function () {
        rpcEmitter.off(cfg.announceEvent, onAnnounce);
        rpcEmitter.off(cfg.discoveryEvent, onDiscovery);
      });

      // disconnect services
      var filter = {
        parent: self.name
      };
      var relatedServices = _.where(Service.list, filter);
      var i;
      var destroyed = 0;
      var max = relatedServices.length;
      var relatedServicesDestroyed;

      function _destroy() {
        destroyed++;
        relatedServicesDestroyed = (destroyed === max);
        callback(cb);
      }

      if (max &gt; 0) {
        for (i = relatedServices.length -1; i &gt;= 0; i--) {
          relatedServices[i].destroy(_destroy);
        }
      } else {
        relatedServicesDestroyed = true;
      }

      var repClosed;
      rep.close(function () {
        repClosed = true;
        callback(cb);
      });
      return this;
    }

<span id='node_modules-synapsejs-Rpc-method-addListener'>    /**
</span>     * Add a listener for the specified event.
     * @param {String} event The event.
     * @param {Function} listener The function to call when the event occurs.
     * @return {Rpc}
     * @chainable
     */
    this.addListener = function addListener(event, listener) {
      localEmitter.addListener(event, listener);
      return self;
    };
<span id='node_modules-synapsejs-Rpc-method-removeListener'>    /**
</span>     * Remove the listener for the specified event.
     * @param {String} event The event.
     * @param {Function} listener The function to remove when the event occurs.
     * @return {Rpc}
     * @chainable
     */
    this.removeListener = function removeListener(event, listener) {
      localEmitter.removeListener(event, listener);
      return self;
    };
<span id='node_modules-synapsejs-Rpc-method-removeAllListeners'>    /**
</span>     * Remove all listener or only all listeners for the event if specified.
     * @param {String} [event] The event.
     * @return {Rpc}
     * @chainable
     */
    this.removeAllListeners = function removeAllListeners(event) {
      localEmitter.removeAllListeners(event);
      return self;
    };
<span id='node_modules-synapsejs-Rpc-method-once'>    /**
</span>     * Add a listener for the specified event but remove it after the first call.
     * @param {String} event The event.
     * @param {Function} listener The function to call when the event occurs.
     * @return {Rpc}
     * @chainable
     */
    this.once = function once(event, listener) {
      localEmitter.once(event, listener);
      return self;
    };
<span id='node_modules-synapsejs-Rpc-method-on'>    /**
</span>     * Alias for addListener.
     * @method on
     * @inheritdoc #addListener
     * @chainable
     */
    this.on = this.addListener;
<span id='node_modules-synapsejs-Rpc-method-off'>    /**
</span>     * Alias for removeListener.
     * @method off
     * @inheritdoc #removeListener
     * @chainable
     */
    this.off = this.removeListener;
<span id='node_modules-synapsejs-Rpc-method-announce'>    /**
</span>     * Announce this new synapse node instance on the network.
     * @method
     * @chainable
     * @fires announce
     */
    this.announce = announce;
<span id='node_modules-synapsejs-Rpc-method-discovery'>    /**
</span>     * Discovery all synapse node on the network.
     * @method
     * @chainable
     * @fires discovery
     */
    this.discovery = discovery;
<span id='node_modules-synapsejs-Rpc-method-start'>    /**
</span>     * Start the synapse node.
     * @param {Boolean} [ghost = false] Set true if no announce event and no discovery response is required (ghost mode).
     * @param {Object} [meta] Optional information available in config.
     * @param {Function} cb The callback after the start.
     * @param {Error|String} cb.err The error if occurred.
     * @param {Object} cb.config The config of the started node (service).
     * @param {String} cb.config.name The name of the service.
     * @param {String} cb.config.address The address of the service.
     * @param {Number|String} cb.config.port The port of the service or 'ghost' if the service is in ghost mode.
     * @param {Object} cb.config.meta Optional information about the service.
     * @fires start
     * @chainable
     */
    this.start = start;
<span id='node_modules-synapsejs-Rpc-method-stop'>    /**
</span>     * Stop the synapse node.
     * @param {Function} cb The callback after the stop.
     * @param {Error|String} cb.err The error if occurred.
     * @param {Object} cb.config The config of the stopped node (service).
     * @param {String} cb.config.name The name of the service.
     * @param {String} cb.config.address The address of the service.
     * @param {Number|String} cb.config.port The port of the service or 'ghost' if the service is in ghost mode.
     * @fires stop
     * @chainable
     */
    this.stop = stop;
<span id='node_modules-synapsejs-Rpc-method-expose'>    /**
</span>     * Expose many or a single method.
     *
     * ## Example
     *
     * ```js
     * var Synapse = require('synapsejs');
     * var rpc = new Synapse();
     * rpc
     *    .expose('sum', function (a, b, cb) {
     *      cb(a + b);
     *    });
     *    .expose('sub', function (a, b, cb) {
     *      cb(a - b);
     *    });
     *
     * // or alternatively
     *
     * rpc.expose({
     *    sum: function (a, b, cb) {
     *      cb(a + b);
     *    },
     *    sub: function (a, b, cb) {
     *      cb(a - b);
     *    }
     * });
     * ```
     *
     * @param {String|Object} name The name of the exposed method
     * @param {String|Object} fn The function exposed.
     *
     * __NOTE__ The function __MUST__ return the result using a callback whose first argument is the error if occurred or null if no error was occurred.
     * @fires expose
     * @method
     * @chainable
     */
    this.expose = expose;
<span id='node_modules-synapsejs-Rpc-method-execute'>    /**
</span>     * Execute a remote method searching it into all nodes.
     *
     * ## Example
     *
     * ```js
     * var Synapse = require('synapsejs');
     * var rpc = new Synapse();
     * rpc.execute('sum', 1, 2, function (err, result) {
     *    console.log(result);    // 3
     * });
     * ```
     *
     * @param {String} name The name of the method. It is possible to specify the method name only or a full qualified name depending on the number of the nodes with the same method name exposed:
     *    - `method`: the name of the method
     *    - `service`.`method`: the name of the service and the name of the method
     *    - `service`@`address`.`method`: the name of the service with its address and the name of the method
     *    - `service`@`address`:`port`.`method`: the name of the service with its address and port and the name of the method
     * @param {Mixed} [arguments] All params required by the remote method.
     * @param {Function} fn The callback with the result of the method.
     * @param {Error|String} fn.err The error if occurred or null if no error was occurred.
     * @param {Mixed} [fn.arguments] All results provided by the remote method.
     * @method
     * @chainable
     */
    this.execute = execute;
  }

<span id='node_modules-synapsejs-Rpc-method-find'>  /**
</span>   * Find a service(s) using some properties.
   * @param {Object} criteria An object with the properties to use as filter
   * (e.g.: { name: 'some name', address: '192.168.0.10' })
   * @return {Array}
   */
  Rpc.prototype.find = function find(criteria) {
    debug('%s find services with criteria %o', this.name, criteria);
    return _.where(this.services, criteria);
  };

<span id='node_modules-synapsejs-Rpc-method-findByMethod'>  /**
</span>   * Find a service(s) using its name.
   * @param {String} name The name of the service to find.
   * @return {Array}
   */
  Rpc.prototype.findByMethod = function findByMethod(name) {
    debug('%s find services with method %s', this.name, name);
    return _.filter(this.services, function (service) {
      return !_.isEmpty(_.filter(service.methods, function (method) {
        return method.name.toString() === name.toString();
      }));
    });
  };

<span id='node_modules-synapsejs-Rpc-method-addRule'>  /**
</span>   * Add a rule to the ACL list used to block a service or a group of services using a regular expressions.
   *
   * ## Example
   *
   *      var rpc = new Rpc({
   *        name: '(acl)'
   *      });
   *      rpc.addRule({
   *        name:    /\([\s\S]+\)/i,                          // any name inside two brackets (case insensitive)
   *        address: /192.168.0.(3[2-9]|[4-5][0-9]|6[0-4])/   // any IP between 192.168.0.32 and 192.168.0.64
   *      });
   *
   * __Note:__ as a firewall the rules are evaluated from the top to the bottom.
   * @param {Object} acl An object with a regular expression as value for every property.
   * @param {String|RegExp} acl.name The name of the blocked service.
   * @param {String|RegExp} acl.address The name of the blocked service.
   * @param {Number|RegExp} acl.port The port of the blocked service.
   * @return {Boolean} True if the acl is successfully added to the ACL list (#rules) or it already exists.
   */
  Rpc.prototype.addRule = function addRule(acl) {
    acl = acl || {};
    if (!_.isEmpty(acl)) {
      if (!~this.rules.indexOf(acl)) {
        debug('%s add rule %o', this.name, acl);
        this.rules.push(acl);
      }
      return true;
    }
    return false;
  };

<span id='node_modules-synapsejs-Rpc-method-removeRule'>  /**
</span>   * Remove a rule from the ACL list used to block a service or a group of services.
   * @param {Object} acl An object with a regular expression as value for every property.
   * @param {String|RegExp} acl.name The name of the blocked service.
   * @param {String|RegExp} acl.address The name of the blocked service.
   * @param {Number|RegExp} acl.port The port of the blocked service.
   */
  Rpc.prototype.removeRule = function removeRule(acl) {
    acl = acl || {};
    if (!_.isEmpty(acl) &amp;&amp; !_.isEmpty(this.rules)) {
      debug('%s remove rule %o', this.name, acl);
      var acls = _.where(this.rules, acl);
      if (!_.isEmpty(acls)) {
        var i, idx;
        for (i = acls.length - 1; i &gt;=0; i--) {
          idx = this.rules.indexOf(acls[i]);
          if (~idx) {
            this.rules.splice(idx, 1);
            acls.splice(i, 1);
          }
        }
      }
    }
  };

<span id='node_modules-synapsejs-Rpc-method-removeAllRules'>  /**
</span>   * Remove all rules from the ACL list used to block a service or a group of services.
   */
  Rpc.prototype.removeAllRules = function removeAllRules() {
    debug('%s remove all ACL rules', this.name);
    while (this.rules.length &gt; 0) {
      this.rules.pop();
    }
  };

<span id='node_modules-synapsejs-Rpc-method-addToBlacklist'>  /**
</span>   * Add a service to the blacklist.
   * @param {Object} service The service to add
   * @param {String} service.name The name of the service.
   * @param {String} service.address The name of the service.
   * @param {Number} service.port The port of the service.
   * @return {Boolean} True if the service is successfully added to the blacklist or it already exists.
   */
  Rpc.prototype.addToBlacklist = function addToBlacklist(service) {
    service = service || {};
    if (!_.isEmpty(service)) {
      if (_.isEmpty(_.find(this.blacklist, service))) {
        debug('%s add to blacklist %o', this.name, service);
        this.blacklist.push(service);
        // if the service is also discovered it must be destroyed
        // FIXME: use Service.list
        _.forEach(_.where(Service.list, service), function (item) {
          item.destroy();
        });
      }
      return true;
    }
    return false;
  };

<span id='node_modules-synapsejs-Rpc-method-flushBlacklist'>  /**
</span>   * Remove all items into the blacklist.
   */
  Rpc.prototype.flushBlacklist = function flushBlacklist() {
    debug('%s flush blacklist', this.name);
    while (this.blacklist.length &gt; 0) {
      this.blacklist.pop();
    }
  };

<span id='node_modules-synapsejs-Rpc-method-checkService'>  /**
</span>   * Verify if a service is into the blacklist or match at least one of the optional ACLs or all rules (ACLs list).
   * @param {Object} service The service to check
   * @param {String} service.name The name of the service.
   * @param {String} service.address The name of the service.
   * @param {Number} service.port The port of the service.
   * @param {Array} [rules] An array of ACL objects with a regular expression as value for every property.
   * The ACL have at least one property of the service (name, address, port).
   * @param {Boolean} [add = false] add True if you want add the service to the blacklist when the test is true.
   * @return {Boolean} True if the ACL match at least one service into the blacklist.
   */
  Rpc.prototype.checkService = function checkService(service, rules, add) {
    var args = norm(arguments, [norm.object({}), norm.array([]), norm.boolean(false)]);
    service = args[0];
    rules = _.isEmpty(args[1]) ? this.rules : args[1];
    add = args[2];
    var match = false;
    var i;
    var rule;
    var keys;
    var test;
    // verify that the service is into the blacklist
    if (_.findWhere(this.blacklist, service)) {
      match = true;
      add = false;
    } else {
      // verify if the service match at least one ACL
      for (i = 0; i &lt; rules.length; i++) {
        rule = rules[i];
        keys = _.keys(rule);
        test = _.pick(service, keys);
        match = true;
        _.forEach(keys, function (key) {
          match = match &amp;&amp; rule[key].test(test[key]);
        });
        if (match) {
          break;
        }
      }
    }
    if (add &amp;&amp; match &amp;&amp; _.isEmpty(_.findWhere(this.blacklist, service))) {
      this.addToBlacklist(service);
    }

    return match;
  };

<span id='node_modules-synapsejs-Rpc-property-services'>  /**
</span>   * All collected services.
   * @property {Array} services
   * @readonly
   */
  Object.defineProperty(Rpc.prototype, 'services', {
    get: function () {
      return _.map(Service.list, function (service) {
        return {
          name: service.name,
          address: service.address,
          port: service.port,
          meta: service.meta,
          methods: service.methods
        };
      });
    }
  });

<span id='node_modules-synapsejs-Rpc-property-servicesByName'>  /**
</span>   * All collected services grouped by name. Every group property is an Array.
   * @property {Object} servicesByName
   * @readonly
   */
  Object.defineProperty(Rpc.prototype, 'servicesByName', {
    get: function () {
      return _.groupBy(this.services, 'name');
    }
  });

<span id='node_modules-synapsejs-Rpc-property-servicesByAddress'>  /**
</span>   * All collected services grouped by address. Every group property is an Array.
   * @property {Object} servicesByAddress
   * @readonly
   */
  Object.defineProperty(Rpc.prototype, 'servicesByAddress', {
    get: function () {
      return _.groupBy(this.services, 'address');
    }
  });

<span id='node_modules-synapsejs-Rpc-property-servicesByPort'>  /**
</span>   * All collected services grouped by port. Every group property is an Array.
   * @property {Object} servicesByPort
   * @readonly
   */
  Object.defineProperty(Rpc.prototype, 'servicesByPort', {
    get: function () {
      return _.groupBy(this.services, 'port');
    }
  });

<span id='node_modules-synapsejs-Rpc-property-servicesByMethod'>  /**
</span>   * All collected services grouped by method. Every group property is an Array.
   * @property {Object} servicesByMethod
   * @readonly
   */
  Object.defineProperty(Rpc.prototype, 'servicesByMethod', {
    get: function () {
      var flatten = [];
      _.forEach(this.services, function (service) {
        _.forEach(_.keys(service.methods), function (name) {
          service.method = name;
          flatten.push(service);
        });
      });
      // group services by method
      flatten = _.groupBy(flatten, 'method');
      // remove 'method' property in every service
      _.forEach(_.keys(flatten), function (method) {
        _.forEach(flatten[method], function (service) {
          delete service.method;
        });
      });
      return flatten;
    }
  });

<span id='node_modules-synapsejs-Rpc-property-config'>  /**
</span>   * The configuration of the synapse node. Other nodes collect it as a service with its exposed methods.
   * @property {Object} config
   * @property {String} config.name The name of the synapse node (service).
   * @property {String} config.address The address of the service.
   * @property {Number} config.port The port of the service.
   * @property {Object} config.meta Optional information about the service.
   * @readonly
   */
  Object.defineProperty(Rpc.prototype, 'config', {
    get: function () {
      return {
        name: this.name,
        address: this.address,
        port: this.port,
        meta: this.meta
      };
    },
    enumerable: true
  });

  return Rpc;
};
</pre>
</body>
</html>
